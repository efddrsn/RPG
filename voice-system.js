// Sistema de Voz para Delphos AI
// Suporta speech-to-text e text-to-speech com vozes diferentes para modo normal e irrestrito

class DelphosVoiceSystem {
    constructor() {
        // Verificar suporte do navegador
        this.speechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.speechSynthesis = window.speechSynthesis;
        
        // Estado do sistema
        this.isListening = false;
        this.isSpeaking = false;
        this.voiceMode = 'normal'; // 'normal' ou 'demonic'
        this.autoListen = false; // Para modo conversacional cont√≠nuo
        
        // Configura√ß√µes de voz
        this.voices = {
            normal: null,
            demonic: null
        };
        
        // Configura√ß√µes de efeitos para voz demon√≠aca
        this.demonicEffects = {
            pitch: 0.3,      // Tom mais grave
            rate: 0.8,       // Velocidade mais lenta
            volume: 1.0,
            // Efeitos adicionais ser√£o aplicados via Web Audio API
            reverb: 0.7,
            distortion: 0.5
        };
        
        // Inicializar reconhecimento de voz
        if (this.speechRecognition) {
            this.recognition = new this.speechRecognition();
            this.setupRecognition();
        }
        
        // Carregar vozes dispon√≠veis
        this.loadVoices();
        
        // Configurar Web Audio API para efeitos demon√≠acos
        this.audioContext = null;
        this.setupAudioEffects();
    }
    
    // Configurar reconhecimento de voz
    setupRecognition() {
        this.recognition.continuous = false;
        this.recognition.interimResults = true;
        this.recognition.lang = 'pt-BR';
        
        this.recognition.onstart = () => {
            this.isListening = true;
            this.updateUI('listening');
            console.log('üé§ Ouvindo...');
        };
        
        this.recognition.onresult = (event) => {
            const current = event.resultIndex;
            const transcript = event.results[current][0].transcript;
            
            if (event.results[current].isFinal) {
                console.log('üìù Transcri√ß√£o final:', transcript);
                this.handleVoiceInput(transcript);
            } else {
                // Mostrar transcri√ß√£o parcial
                this.updateTranscript(transcript, false);
            }
        };
        
        this.recognition.onerror = (event) => {
            console.error('‚ùå Erro no reconhecimento:', event.error);
            this.isListening = false;
            this.updateUI('error', event.error);
        };
        
        this.recognition.onend = () => {
            this.isListening = false;
            this.updateUI('idle');
            
            // Reiniciar se estiver em modo conversacional
            if (this.autoListen && !this.isSpeaking) {
                setTimeout(() => this.startListening(), 500);
            }
        };
    }
    
    // Carregar vozes dispon√≠veis
    loadVoices() {
        const setVoices = () => {
            const availableVoices = this.speechSynthesis.getVoices();
            
            // Procurar voz em portugu√™s para modo normal
            this.voices.normal = availableVoices.find(voice => 
                voice.lang.includes('pt-BR') && voice.name.includes('Google')
            ) || availableVoices.find(voice => 
                voice.lang.includes('pt-BR')
            ) || availableVoices[0];
            
            // Para voz demon√≠aca, preferir uma voz masculina grave
            this.voices.demonic = availableVoices.find(voice => 
                voice.lang.includes('pt-BR') && 
                (voice.name.toLowerCase().includes('male') || 
                 voice.name.toLowerCase().includes('masculino'))
            ) || this.voices.normal;
            
            console.log('üîä Vozes carregadas:', {
                normal: this.voices.normal?.name,
                demonic: this.voices.demonic?.name
            });
        };
        
        // Carregar vozes quando dispon√≠veis
        if (this.speechSynthesis.getVoices().length > 0) {
            setVoices();
        } else {
            this.speechSynthesis.onvoiceschanged = setVoices;
        }
    }
    
    // Configurar Web Audio API para efeitos
    setupAudioEffects() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Criar n√≥s de efeitos
            this.effects = {
                distortion: this.createDistortion(),
                reverb: this.createReverb(),
                lowpass: this.audioContext.createBiquadFilter()
            };
            
            // Configurar filtro passa-baixa para som mais grave
            this.effects.lowpass.type = 'lowpass';
            this.effects.lowpass.frequency.value = 800;
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Web Audio API n√£o dispon√≠vel:', error);
        }
    }
    
    // Criar efeito de distor√ß√£o
    createDistortion() {
        const samples = 44100;
        const curve = new Float32Array(samples);
        const deg = Math.PI / 180;
        
        for (let i = 0; i < samples; i++) {
            const x = (i * 2) / samples - 1;
            curve[i] = ((3 + 10) * x * 20 * deg) / (Math.PI + 10 * Math.abs(x));
        }
        
        const distortion = this.audioContext.createWaveShaper();
        distortion.curve = curve;
        distortion.oversample = '4x';
        return distortion;
    }
    
    // Criar efeito de reverbera√ß√£o
    createReverb() {
        const convolver = this.audioContext.createConvolver();
        const length = this.audioContext.sampleRate * 2;
        const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
        }
        
        convolver.buffer = impulse;
        return convolver;
    }
    
    // Iniciar reconhecimento de voz
    startListening() {
        console.log('üé§ startListening chamado');
        
        if (!this.speechRecognition) {
            const msg = 'Seu navegador n√£o suporta reconhecimento de voz! Use Chrome, Edge ou Safari.';
            console.error('‚ùå', msg);
            alert(msg);
            return;
        }
        
        if (this.isListening) {
            console.log('‚ö†Ô∏è J√° est√° ouvindo');
            return;
        }
        
        // Parar s√≠ntese se estiver falando
        if (this.isSpeaking) {
            this.stopSpeaking();
        }
        
        // Solicitar permiss√£o do microfone se necess√°rio
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(() => {
                console.log('‚úÖ Permiss√£o de microfone concedida');
                try {
                    this.recognition.start();
                    console.log('‚úÖ Reconhecimento iniciado');
                } catch (error) {
                    console.error('‚ùå Erro ao iniciar reconhecimento:', error);
                    if (error.message.includes('already started')) {
                        // Tentar parar e reiniciar
                        this.recognition.stop();
                        setTimeout(() => {
                            try {
                                this.recognition.start();
                            } catch (e) {
                                console.error('‚ùå Erro ao reiniciar:', e);
                            }
                        }, 100);
                    }
                }
            })
            .catch((error) => {
                console.error('‚ùå Erro ao obter permiss√£o do microfone:', error);
                alert('Por favor, permita o acesso ao microfone para usar o reconhecimento de voz.');
            });
    }
    
    // Parar reconhecimento
    stopListening() {
        if (this.isListening) {
            this.recognition.stop();
        }
    }
    
    // Sintetizar fala
    speak(text, isUnrestricted = false) {
        console.log(`üîä speak chamado: "${text.substring(0, 50)}..." (modo ${isUnrestricted ? 'demon√≠aco' : 'normal'})`);
        
        return new Promise((resolve) => {
            if (!this.speechSynthesis) {
                console.error('‚ùå S√≠ntese de voz n√£o dispon√≠vel');
                alert('S√≠ntese de voz n√£o est√° dispon√≠vel no seu navegador.');
                resolve();
                return;
            }
            
            // Verificar se as vozes foram carregadas
            if (!this.voices.normal) {
                console.warn('‚ö†Ô∏è Vozes ainda n√£o carregadas, tentando carregar...');
                this.loadVoices();
                // Tentar novamente ap√≥s um delay
                setTimeout(() => this.speak(text, isUnrestricted).then(resolve), 500);
                return;
            }
            
            // Parar qualquer fala anterior
            this.stopSpeaking();
            
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Configurar voz baseada no modo
            if (isUnrestricted) {
                utterance.voice = this.voices.demonic;
                utterance.pitch = this.demonicEffects.pitch;
                utterance.rate = this.demonicEffects.rate;
                utterance.volume = this.demonicEffects.volume;
                
                // Adicionar efeitos extras se poss√≠vel
                this.applyDemonicEffects(utterance);
            } else {
                utterance.voice = this.voices.normal;
                utterance.pitch = 1.0;
                utterance.rate = 1.0;
                utterance.volume = 1.0;
            }
            
            utterance.lang = 'pt-BR';
            
            utterance.onstart = () => {
                this.isSpeaking = true;
                this.updateUI('speaking');
                console.log('üîä Falando' + (isUnrestricted ? ' (modo demon√≠aco)' : '') + '...');
            };
            
            utterance.onend = () => {
                this.isSpeaking = false;
                this.updateUI('idle');
                resolve();
                
                // Reiniciar escuta se em modo conversacional
                if (this.autoListen) {
                    setTimeout(() => this.startListening(), 500);
                }
            };
            
            utterance.onerror = (event) => {
                console.error('Erro na s√≠ntese:', event);
                this.isSpeaking = false;
                this.updateUI('error');
                resolve();
            };
            
            this.speechSynthesis.speak(utterance);
        });
    }
    
    // Aplicar efeitos demon√≠acos adicionais
    applyDemonicEffects(utterance) {
        // Adicionar pequenas pausas aleat√≥rias para efeito sinistro
        const words = utterance.text.split(' ');
        const modifiedText = words.map((word, index) => {
            if (index > 0 && Math.random() < 0.2) {
                return '... ' + word;
            }
            return word;
        }).join(' ');
        
        utterance.text = modifiedText;
        
        // Adicionar risada demon√≠aca ocasional
        if (Math.random() < 0.1) {
            utterance.text += '... h√° h√° h√°...';
        }
    }
    
    // Parar s√≠ntese
    stopSpeaking() {
        if (this.isSpeaking) {
            this.speechSynthesis.cancel();
            this.isSpeaking = false;
            this.updateUI('idle');
        }
    }
    
    // Lidar com entrada de voz
    handleVoiceInput(transcript) {
        // Enviar para o chat principal
        const userInput = document.getElementById('user-input');
        userInput.value = transcript;
        
        // Disparar evento de envio
        const sendBtn = document.getElementById('send-btn');
        sendBtn.click();
        
        this.updateTranscript(transcript, true);
    }
    
    // Atualizar transcri√ß√£o na UI
    updateTranscript(text, isFinal) {
        const indicator = document.getElementById('voice-transcript');
        if (indicator) {
            indicator.textContent = text;
            indicator.classList.toggle('final', isFinal);
        }
    }
    
    // Atualizar interface de usu√°rio
    updateUI(state, error = null) {
        const voiceBtn = document.getElementById('voice-btn');
        const voiceIndicator = document.getElementById('voice-indicator');
        
        if (!voiceBtn || !voiceIndicator) return;
        
        // Remover todas as classes de estado
        voiceIndicator.classList.remove('listening', 'speaking', 'error');
        
        switch (state) {
            case 'listening':
                voiceBtn.textContent = 'üé§';
                voiceIndicator.classList.add('listening');
                voiceIndicator.title = 'Ouvindo...';
                break;
                
            case 'speaking':
                voiceBtn.textContent = 'üîä';
                voiceIndicator.classList.add('speaking');
                voiceIndicator.title = 'Falando...';
                break;
                
            case 'error':
                voiceBtn.textContent = '‚ùå';
                voiceIndicator.classList.add('error');
                voiceIndicator.title = `Erro: ${error || 'Desconhecido'}`;
                break;
                
            default: // idle
                voiceBtn.textContent = 'üéôÔ∏è';
                voiceIndicator.title = 'Clique para falar';
        }
    }
    
    // Alternar modo conversacional
    toggleConversationalMode() {
        this.autoListen = !this.autoListen;
        
        if (this.autoListen) {
            console.log('üîÑ Modo conversacional ativado');
            if (!this.isListening && !this.isSpeaking) {
                this.startListening();
            }
        } else {
            console.log('‚è∏Ô∏è Modo conversacional desativado');
        }
        
        return this.autoListen;
    }
    
    // Definir modo de voz (normal ou demon√≠aco)
    setVoiceMode(mode) {
        this.voiceMode = mode;
        console.log(`üé≠ Modo de voz alterado para: ${mode}`);
    }
}

// Exportar para uso global
window.DelphosVoiceSystem = DelphosVoiceSystem;