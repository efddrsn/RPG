<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Delfos - Demo de Voz</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; min-height: 100dvh; display: grid; place-items: center; background: var(--bg); color: var(--text); position: relative; overflow-x: hidden; }
      /* THEME VARIABLES */
      body.mode-normal {
        --bg: #f7fafc;
        --text: #0b1020;
        --card-bg: #ffffff;
        --border: #e2e8f0;
        --accent: #2563eb;
        --accent-2: #38bdf8;
        --orb-base: #1d4ed8;
        --orb-highlight: #3b82f6;
        --orb-glow: rgba(59,130,246,.45);
        --orb-wave: rgba(59,130,246,.30);
      }
      body.mode-unrestricted {
        --bg: #0b1020;
        --text: #e6e9ef;
        --card-bg: #0f152b;
        --border: #2a2f45;
        --accent: #7b2cff;
        --accent-2: #22d3ee;
        --orb-base: #0a0f1e;
        --orb-highlight: #232a44;
        --orb-glow: rgba(2,6,23,.65);
        --orb-wave: rgba(148,163,184,.18);
      }
      /* Ritual symbols background for unrestricted mode */
      body.mode-unrestricted::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image:
          radial-gradient(1000px 1000px at 50% -10%, rgba(123,44,255,.12), transparent 60%),
          url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='240' height='240' viewBox='0 0 240 240'><rect width='240' height='240' fill='none'/><g fill='%23ffffff' fill-opacity='0.06' font-size='20' font-family='ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace'><text x='16' y='36'>⟡ ✶ ☽ ☉ ☿ ♄ ✴</text><text x='64' y='84'>✧ ⟁ ⊕ ⊗ ☌ ☍</text><text x='28' y='132'>☯ ✦ ⛤ ⛧ ✵ ✹</text><text x='92' y='180'>✷ ✴ ✹ ⍟ ⍣ ✶</text></g></svg>");
        background-size: auto, 260px 260px;
        background-repeat: no-repeat, repeat;
        mix-blend-mode: screen;
        opacity: .5;
        pointer-events: none;
        z-index: 0;
      }
      .card { width: min(720px, 92vw); border: 1px solid var(--border); border-radius: 12px; padding: 20px; background: var(--card-bg); box-shadow: 0 10px 30px rgba(0,0,0,.15); position: relative; z-index: 1; }
      .title { margin: 0 0 6px; font-size: 20px; font-weight: 600; letter-spacing: .2px; }
      .subtitle { margin: 0 0 16px; font-size: 13px; opacity: .8; }
      .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .spacer { height: 10px; }
      .toggle { display: inline-flex; align-items: center; gap: 8px; border: 1px solid var(--border); border-radius: 999px; padding: 6px 10px; background: rgba(0,0,0,.04); }
      .toggle input { appearance: none; width: 42px; height: 24px; background: rgba(0,0,0,.25); border-radius: 999px; position: relative; outline: none; cursor: pointer; transition: background .2s ease; }
      .toggle input::after { content: ""; position: absolute; top: 3px; left: 3px; width: 18px; height: 18px; background: var(--text); border-radius: 50%; transition: transform .2s ease; }
      .toggle input:checked { background: var(--accent); }
      .toggle input:checked::after { transform: translateX(18px); }
      .btn { appearance: none; border: 1px solid var(--border); background: rgba(0,0,0,.06); color: var(--text); padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 600; }
      .btn:hover { background: rgba(0,0,0,.10); }
      .status { font-size: 12px; opacity: .8; }
      .orb-scene { margin-top: 14px; border: 1px dashed var(--border); border-radius: 12px; padding: 24px; display: grid; place-items: center; min-height: 180px; background: rgba(0,0,0,.04); }
      .orb { width: 160px; height: 160px; border-radius: 50%; position: relative; background: radial-gradient( circle at 35% 35%, var(--orb-highlight), var(--orb-base) 60% ); box-shadow: 0 0 40px var(--orb-glow), inset 0 0 20px rgba(255,255,255,.06); }
      .orb::after { content: ""; position: absolute; inset: 0; border-radius: 50%; background: radial-gradient(circle at 35% 35%, rgba(255,255,255,.18), transparent 45%); animation: breathe 4s ease-in-out infinite; }
      .ring { position: absolute; left: 50%; top: 50%; width: 140px; height: 140px; margin-left: -70px; margin-top: -70px; border-radius: 50%; box-shadow: 0 0 0 1px var(--orb-wave) inset; animation: ripple 3s linear infinite; }
      .ring:nth-child(1) { animation-delay: 0s; }
      .ring:nth-child(2) { animation-delay: 1s; }
      .ring:nth-child(3) { animation-delay: 2s; }
      @keyframes ripple { 0% { transform: scale(1); opacity: .6; } 70% { opacity: .18; } 100% { transform: scale(2.3); opacity: 0; } }
      @keyframes breathe { 0%,100% { transform: scale(0.98); } 50% { transform: scale(1.02); } }
    </style>
  </head>
  <body>
    <main class="card">
      <h1 class="title">Delfos — Demo de Voz</h1>
      <p class="subtitle">Use o botão para autorizar o microfone e o toggle para alternar entre modo normal e irrestrito. A conversa é contínua após iniciar.</p>

      <div class="row">
        <label class="toggle" title="Alternar modo irrestrito">
          <span>Normal</span>
          <input id="modeToggle" type="checkbox" />
          <span>Irrestrito</span>
        </label>
        <button id="startBtn" class="btn">Iniciar conversa</button>
        <span id="status" class="status"></span>
      </div>

      <div class="orb-scene" aria-hidden="true">
        <div class="orb">
          <span class="ring"></span>
          <span class="ring"></span>
          <span class="ring"></span>
        </div>
      </div>
    </main>

    <script type="module">
      // Carrega o SDK da Vapi priorizando UMD (mais compatível), com fallbacks
      let VapiCtor = null;
      async function loadVapi() {
        if (VapiCtor) return VapiCtor;
        // 1) Tenta UMD por diferentes CDNs
        const umdUrls = [
          'https://cdn.jsdelivr.net/npm/@vapi-ai/web/dist/index.umd.js',
          'https://cdn.jsdelivr.net/npm/@vapi-ai/web',
          'https://unpkg.com/@vapi-ai/web@latest/dist/index.umd.js'
        ];
        for (const url of umdUrls) {
          try {
            await new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = url;
              s.async = true;
              s.defer = true;
              s.onload = resolve;
              s.onerror = reject;
              document.head.appendChild(s);
            });
            const candidate = (window.Vapi && (window.Vapi.default || window.Vapi)) || window.VapiWeb || window.VapiAI || window.vapi;
            if (typeof candidate === 'function') {
              VapiCtor = candidate;
              return VapiCtor;
            }
          } catch {}
        }
        // 2) Fallback ESM
        const esmUrls = [
          'https://cdn.jsdelivr.net/npm/@vapi-ai/web/+esm',
          'https://esm.sh/@vapi-ai/web',
          'https://cdn.skypack.dev/@vapi-ai/web'
        ];
        for (const url of esmUrls) {
          try {
            const mod = await import(url);
            const candidate = mod?.default ?? mod?.Vapi ?? mod?.VapiWeb ?? mod;
            if (typeof candidate === 'function') {
              VapiCtor = candidate;
              return VapiCtor;
            }
          } catch {}
        }
        throw new Error('Não foi possível carregar o SDK da Vapi a partir das CDNs conhecidas.');
      }

      const NORMAL_ASSISTANT_ID = 'b7146a9e-bae1-4245-87f7-e72b1335ac55';
      const UNRESTRICTED_ASSISTANT_ID = 'aa7f1b14-8dbc-4a59-9f5e-16079eae4da7';
      const PUBLIC_KEY = '13eed109-a96b-434f-90b6-60d81c28663d';

      const startBtn = document.getElementById('startBtn');
      const modeToggle = document.getElementById('modeToggle');
      const statusEl = document.getElementById('status');

      function setStatus(text) { statusEl.textContent = text; }
      function applyMode() {
        document.body.classList.toggle('mode-unrestricted', modeToggle.checked);
        document.body.classList.toggle('mode-normal', !modeToggle.checked);
      }

      async function ensureMicPermission() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(track => track.stop());
          return true;
        } catch (err) {
          console.error('Mic permission error:', err);
          return false;
        }
      }

      let vapi = null;
      async function ensureVapi() {
        if (vapi) return vapi;
        const VapiClass = await loadVapi();
        vapi = new VapiClass(PUBLIC_KEY);
        vapi.on('call-start', () => {
          setStatus('Chamada iniciada. Fale com a Delfos.');
        });
        vapi.on('call-end', () => {
          setStatus('Chamada encerrada.');
        });
        // Transcript handling removido para uma interface mais clean
        vapi.on('error', (err) => {
          console.error(err);
          setStatus('Erro na chamada.');
        });
        return vapi;
      }

      function getAssistantId() {
        return modeToggle.checked ? UNRESTRICTED_ASSISTANT_ID : NORMAL_ASSISTANT_ID;
      }

      async function startConversation() {
        setStatus('Solicitando acesso ao microfone...');
        const granted = await ensureMicPermission();
        if (!granted) {
          setStatus('Permissão do microfone negada. Autorize para continuar.');
          return;
        }
        setStatus('Carregando Vapi...');
        try {
          await ensureVapi();
        } catch (e) {
          console.error(e);
          setStatus('Falha ao carregar o SDK da Vapi.');
          return;
        }
        setStatus('Conectando...');
        try {
          startBtn.disabled = true;
          await vapi.start(getAssistantId());
          // Beep curto para indicar pronto
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.frequency.value = 880; gain.gain.value = 0.02;
            osc.connect(gain).connect(ctx.destination);
            osc.start(); setTimeout(() => { osc.stop(); ctx.close(); }, 120);
          } catch {}
        } catch (err) {
          console.error(err);
          setStatus('Falha ao iniciar a chamada.');
        } finally {
          startBtn.disabled = false;
        }
      }

      modeToggle.addEventListener('change', () => {
        applyMode();
        setStatus(modeToggle.checked ? 'Modo: Irrestrito' : 'Modo: Normal');
      });

      startBtn.addEventListener('click', startConversation);

      // Estado inicial
      applyMode();
      setStatus('Modo: Normal');
    </script>
  </body>
  </html>

